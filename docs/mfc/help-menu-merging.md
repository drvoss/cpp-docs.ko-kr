---
title: 도움말 메뉴 병합
ms.date: 11/04/2016
helpviewer_keywords:
- menus [MFC], merging
- merging Help menus [MFC]
- Help [MFC], for active document containers
ms.assetid: 9d615999-79ba-471a-9288-718f0c903d49
ms.openlocfilehash: 1bd70af6f24ee6f9873b89b2060f4b2d90149c90
ms.sourcegitcommit: c21b05042debc97d14875e019ee9d698691ffc0b
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/09/2020
ms.locfileid: "84620135"
---
# <a name="help-menu-merging"></a>도움말 메뉴 병합

컨테이너 내에서 개체가 활성 상태인 경우 OLE 문서의 메뉴 병합 프로토콜은 개체의 **도움말** 메뉴에 대 한 완전 한 제어를 제공 합니다. 따라서 사용자가 개체를 비활성화 하지 않으면 컨테이너의 도움말 항목을 사용할 수 없습니다. 활성 문서 포함 아키텍처는 컨테이너와 활성 상태인 활성 문서가 모두 메뉴를 공유할 수 있도록 내부 메뉴 병합에 대 한 규칙을 확장 합니다. 새 규칙은 메뉴의 어느 부분을 소유 하 고 있는 구성 요소와 공유 메뉴가 생성 되는 방식에 대 한 추가 규칙입니다.

새 규칙은 간단 합니다. 활성 문서에서 **도움말** 메뉴에는 다음과 같이 구성 된 두 개의 최상위 메뉴 항목이 있습니다.

`Help`

`Container Help >`

`Object Help    >`

예를 들어, Office 바인더에서 단어 섹션이 활성화 된 경우 **도움말** 메뉴가 다음과 같이 표시 됩니다.

`Help`

`Binder Help >`

`Word Help   >`

두 메뉴 항목은 모두 컨테이너 및 개체와 관련 된 추가 메뉴 항목이 사용자에 게 제공 되는 계단식 메뉴입니다. 여기에 표시 되는 항목은 관련 된 컨테이너 및 개체에 따라 달라 집니다.

이 병합 된 **도움말** 메뉴를 생성 하기 위해 액티브 문서 포함 아키텍처는 일반적인 OLE 문서 프로시저를 수정 합니다. OLE 문서에 따라 병합 된 메뉴 모음에는 **파일**, **편집**, **컨테이너**, **개체**, **창**, **도움말**등의 여섯 가지 메뉴 그룹이 포함 될 수 있습니다. 각 그룹에는 0 개 이상의 메뉴가 있을 수 있습니다. 그룹 **파일**, **컨테이너**및 **창은** 컨테이너에 속하고 그룹 **편집**, **개체** 및 **도움말** 은 개체에 속합니다. 개체가 메뉴 병합을 수행 하려는 경우 빈 메뉴 모음을 만들고 컨테이너에 전달 합니다. 그런 다음를 호출 하 여 컨테이너의 메뉴를 삽입 합니다 `IOleInPlaceFrame::InsertMenus` . 또한이 개체는 6 개의 LONG 값 (**OLEMENUGROUPWIDTHS**) 배열인 구조체를 전달 합니다. 메뉴를 삽입 한 후 컨테이너는 각 그룹에 추가 된 메뉴 수를 표시 한 다음을 반환 합니다. 그런 다음 개체는 각 컨테이너 그룹의 메뉴 수에 주의 하 여 메뉴를 삽입 합니다. 마지막으로 개체는 병합 된 메뉴 표시줄과 각 그룹의 메뉴 수가 포함 된 배열을 OLE로 전달 합니다. 그러면 불투명 한 "메뉴 설명자" 핸들이 반환 됩니다. 나중에 개체는을 통해 해당 핸들 및 병합 된 메뉴 모음을 컨테이너에 전달 `IOleInPlaceFrame::SetMenu` 합니다. 이때 컨테이너는 병합 된 메뉴 모음을 표시 하 고 ole에 핸들을 전달 하 여 OLE가 메뉴 메시지를 적절 하 게 디스패치할 수 있도록 합니다.

수정 된 활성 문서 프로시저에서 개체는 먼저 **OLEMENUGROUPWIDTHS** 요소를 0으로 초기화 한 후 컨테이너에 전달 해야 합니다. 그런 다음 컨테이너는 한 가지 예외를 제외 하 고 일반 메뉴 삽입을 수행 합니다. 즉, 컨테이너는 **도움말** 메뉴를 마지막 항목으로 삽입 하 고 **OLEMENUGROUPWIDTHS** 배열의 마지막 (여섯 번째) 항목 (개체의 도움말 그룹에 속하는 너비 [5])에 1 값을 저장 합니다. 이 **도움말** 메뉴에는 앞서 설명한 대로 "**컨테이너 도움말** >" 계단식 메뉴 인 하위 메뉴 항목인 항목이 하나만 포함 됩니다.

그러면 개체는 해당 **도움말** 메뉴를 삽입 하기 전에 **OLEMENUGROUPWIDTHS** 배열의 여섯 번째 항목을 확인 하는 것을 제외 하 고 일반 메뉴 삽입 코드를 실행 합니다. 값이 1이 고 마지막 메뉴의 이름이 **도움말** (또는 적절 한 지역화 된 문자열) 인 경우 개체는 해당 **도움말** 메뉴를 컨테이너의 **도움말** 메뉴의 하위 메뉴로 삽입 합니다.

그러면 개체가 **OLEMENUGROUPWIDTHS** 의 여섯 번째 요소를 0으로 설정 하 고 다섯 번째 요소를 1 씩 증가 시킵니다. 이렇게 하면 OLE에서 **도움말** 메뉴가 컨테이너에 속하며 해당 메뉴와 해당 하위 메뉴에 해당 하는 메뉴 메시지를 컨테이너에 라우팅해야 한다는 것을 알 수 있습니다. 그러면 컨테이너는 **WM_INITMENUPOPUP**, **WM_SELECT**, **WM_COMMAND**및 기타 메뉴 관련 메시지를 **도움말** 메뉴의 개체 부분에만 전달 하는 역할을 합니다. 이렇게 하려면 **WM_INITMENU** 를 사용 하 여 사용자가 개체의 **도움말** 메뉴를 탐색 했는지 여부를 컨테이너에 알리는 플래그를 지웁니다. 그런 다음 컨테이너는 컨테이너 자체를 추가 하지 않은 **도움말** 메뉴의 모든 항목에 대 한 입력 또는 종료 **WM_MENUSELECT** 를 감시 합니다. 항목에서 사용자가 개체 메뉴를 탐색 하는 것을 의미 하므로 컨테이너는 "개체 도움말 메뉴" 플래그를 설정 하 고 해당 플래그의 상태를 사용 하 여 개체 창에 **WM_MENUSELECT**, **WM_INITMENUPOPUP**및 **WM_COMMAND** 메시지를 최소한으로 전달 합니다. 종료 시 컨테이너는 플래그를 지운 다음 동일한 메시지를 처리 합니다. 컨테이너는 개체의 함수에서 반환 된 창을 `IOleInPlaceActiveObejct::GetWindow` 이러한 메시지에 대 한 대상으로 사용 해야 합니다.

개체가 **OLEMENUGROUPWIDTHS**의 여섯 번째 요소에서 0을 검색 하면 일반적인 OLE 문서 규칙에 따라 계속 진행 됩니다. 이 절차에서는 **도움말** 메뉴 병합에 참여 하는 컨테이너 및 그렇지 않은 컨테이너에 대해 설명 합니다.

개체가를 호출할 때 `IOleInPlaceFrame::SetMenu` 병합 된 메뉴 모음을 표시 하기 전에 컨테이너에서 삽입 한 내용 외에도 **도움말** 메뉴에 추가 하위 메뉴가 있는지 여부를 확인 합니다. 이 경우 컨테이너는 병합 된 메뉴 모음에서 **도움말** 메뉴를 벗어납니다. **도움말** 메뉴에 추가 하위 메뉴가 없으면 컨테이너는 병합 된 메뉴 모음에서 **도움말** 메뉴를 제거 합니다. 이 절차에서는 **도움말** 메뉴 병합에 참여 하는 개체 및 그렇지 않은 개체에 대해 설명 합니다.

마지막으로 메뉴를 분해할 때 개체는 삽입 된 다른 메뉴를 제거 하는 것 외에도 삽입 된 **도움말** 메뉴를 제거 합니다. 컨테이너의 메뉴가 제거 되 면 해당 메뉴가 삽입 된 다른 메뉴와 함께 해당 **도움말** 메뉴가 제거 됩니다.

## <a name="see-also"></a>참고 항목

[액티브 문서 컨테이너](active-document-containers.md)

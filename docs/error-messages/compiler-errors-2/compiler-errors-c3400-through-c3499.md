---
title: 컴파일러 오류 C3400 ~ C3499
ms.date: 04/21/2019
f1_keywords:
- C3401
- C3402
- C3403
- C3404
- C3405
- C3406
- C3407
- C3410
- C3411
- C3416
- C3419
- C3422
- C3424
- C3425
- C3426
- C3427
- C3428
- C3429
- C3430
- C3431
- C3432
- C3433
- C3434
- C3435
- C3436
- C3437
- C3438
- C3439
- C3440
- C3441
- C3442
- C3443
- C3444
- C3471
- C3472
- C3473
- C3474
- C3475
- C3476
- C3477
- C3478
- C3479
- C3486
- C3494
- C3497
helpviewer_keywords:
- C3401
- C3402
- C3403
- C3404
- C3405
- C3406
- C3407
- C3410
- C3411
- C3416
- C3419
- C3422
- C3424
- C3425
- C3426
- C3427
- C3428
- C3429
- C3430
- C3431
- C3432
- C3433
- C3434
- C3435
- C3436
- C3437
- C3438
- C3439
- C3440
- C3441
- C3442
- C3443
- C3444
- C3471
- C3472
- C3473
- C3474
- C3475
- C3476
- C3477
- C3478
- C3479
- C3486
- C3494
- C3497
ms.assetid: a5651dfb-c402-4e01-b3ae-28f371e51d6a
ms.openlocfilehash: f4aff80178033d34cf051a14d89736b2b8347dd0
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/17/2020
ms.locfileid: "79446840"
---
# <a name="compiler-errors-c3400-through-c3499"></a>컴파일러 오류 C3400 ~ C3499

설명서의이 섹션에 있는 문서는 컴파일러에 의해 생성 되는 오류 메시지의 하위 집합을 설명 합니다.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>오류 메시지

|Error|메시지|
|-----------|-------------|
|[컴파일러 오류 C3400](compiler-error-c3400.md)|'*t*' 및 '*constraint2*'와 관련 된 순환 제약 조건 종속성|
|컴파일러 오류 C3401|'*지정자*': 어셈블리 액세스 지정 자가 잘못 되었습니다. 클래스 템플릿에서 ' private '만 허용 됩니다.|
|컴파일러 오류 C3402|'*function*': 현재 범위를 제외 하 고는 오버 로드를 확인할 수 없습니다.|
|컴파일러 오류 C3403|thread_local는/clr: pure 또는/clr: safe와 함께 사용할 수 없습니다.|
|컴파일러 오류 C3404|'*구문*': 예기치 않은 구문 오류가 발생 했습니다.|
|컴파일러 오류 C3405|'*function*': 완전 한 설명자 없이는 오버 로드를 확인할 수 없습니다.|
|컴파일러 오류 C3406|'*keyword*': 상세 형식 지정자에 사용할 수 없습니다.|
|컴파일러 오류 C3407|'*type*'은이 컨텍스트에서 사용할 수 없습니다.|
|[컴파일러 오류 C3408](compiler-error-c3408.md)|'*attribute*': 특성을 템플릿 정의에 사용할 수 없습니다.|
|[컴파일러 오류 C3409](compiler-error-c3409.md)|빈 특성 블록은 사용할 수 없습니다.|
|컴파일러 오류 C3410|'*identifier*': 명시적 인스턴스화 '*type*'의 형식이 '*type*' 변수 템플릿의 형식과 일치 하지 않습니다.|
|컴파일러 오류 C3411|'*t r u e '는*정수 형식이 아니므로 배열 크기로 사용할 수 없습니다.|
|[컴파일러 오류 C3412](compiler-error-c3412.md)|'*특수화*': 현재 범위에서 템플릿을 특수화할 수 없습니다.|
|[컴파일러 오류 C3413](compiler-error-c3413.md)|'*template*': 잘못 된 명시적 인스턴스화입니다.|
|[컴파일러 오류 C3414](compiler-error-c3414.md)|'*function*': 가져온 멤버 함수를 정의할 수 없습니다.|
|[컴파일러 오류 C3415](compiler-error-c3415.md)|여러 '*section*' 섹션이 다른 특성 (' 0x*value*')을 사용 하 여 검색 되었습니다.|
|컴파일러 오류 C 3416|더 이상 사용되지 않습니다.|
|[컴파일러 오류 C3417](compiler-error-c3417.md)|'*선언 자*': 값 형식은 사용자 정의 특수 멤버 함수를 포함할 수 없습니다.|
|[컴파일러 오류 C3418](compiler-error-c3418.md)|액세스 지정자 '*지정자*'는 지원 되지 않습니다.|
|컴파일러 오류 C3419|더 이상 사용되지 않습니다.|
|[컴파일러 오류 C3420](compiler-error-c3420.md)|'*function*': 종료자는 virtual 일 수 없습니다.|
|[컴파일러 오류 C3421](compiler-error-c3421.md)|'*function*':이 클래스의 종료자는 액세스할 수 없거나 존재 하지 않으므로 호출할 수 없습니다.|
|컴파일러 오류 C3422|'*선언*': '*type*' 및 '*type*' 형식이 일치 하지 않습니다.|
|컴파일러 오류 C3423|더 이상 사용되지 않습니다.|
|컴파일러 오류 C3424|'*type*': 배열 형식으로의 함수 스타일 캐스트는 허용 되지 않습니다.|
|컴파일러 오류 C3425|불완전 한 '*type*' 형식의 개체에 대 한 포인터를 throw 할 수 없습니다.|
|컴파일러 오류 C3426|불완전 한 '*type*' 형식의 개체를 throw 할 수 없습니다.|
|컴파일러 오류 C3427|'*context*': '*keyword*'는 layout_version (*number*)와 함께 사용할 수 없습니다.|
|컴파일러 오류 C3428|'*context*': '*keyword*'는 클래스 선언 또는 정의에만 적용할 수 있습니다.|
|컴파일러 오류 C3429|'*context*': '*keyword*'는 공용 구조체에 적용할 수 없습니다.|
|컴파일러 오류 C3430|범위가 지정 된 열거형에는 이름이 있어야 합니다.|
|컴파일러 오류 C3431|'*identifier*': *type1* 을 *type2* 로 다시 선언할 수 없습니다.|
|컴파일러 오류 C3432|'*identifier*': 범위가 없는 열거형의 전방 선언에는 내부 형식이 있어야 합니다.|
|컴파일러 오류 C3433|'*identifier*': 열거형의 모든 선언에는 동일한 기본 형식이 있어야 합니다. '*type1*'은 '*type2*'입니다.|
|컴파일러 오류 C3434|'*context*': '*number*' 열거자 값을 '*type*'으로 표시할 수 없습니다. 값은 '*number*'입니다.|
|컴파일러 오류 C3435|'*name*' 문자 집합은 지원 되지 않습니다.|
|컴파일러 오류 C3436|/source-charset,/source-charset 또는/utf-8이 지정 된 경우에는 #pragma setlocale이 지원 되지 않습니다.|
|컴파일러 오류 C3437|/source-charset,/source-charset 또는/utf-8이 지정 된 경우에는 #pragma execution_character_set 지원 되지 않습니다.|
|컴파일러 오류 C3438|'*context*': '*value*'는 관리 되는/WinRT 클래스에 적용할 수 없습니다.|
|컴파일러 오류 C3439|layout_version (*number*): 잘못 된 버전 번호입니다.|
|컴파일러 오류 C3440|'*선언*': layout_version (*number*)가 이전 선언과 호환 되지 않습니다.|
|컴파일러 오류 C3441|'*선언*': 클래스를 정의한 후에는 '*keyword*'를 적용할 수 없습니다.|
|컴파일러 오류 C3442|Union의 여러 멤버를 초기화 하는 중: '*member1*' 및 '*member2*'|
|컴파일러 오류 C3443|'*Class*'의 기본 멤버 이니셜라이저가 재귀적입니다.|
|컴파일러 오류 C3444|'*Class*'의 빈 집계 클래스는 '{}'로 초기화 해야 합니다.|
|[컴파일러 오류 C3445](compiler-error-c3445.md)|'*type*'의 복사 목록 초기화는 명시적 생성자를 사용할 수 없습니다.|
|[컴파일러 오류 C3446](compiler-error-c3446.md)|'*class*': 값 클래스의 멤버에는 기본 멤버 이니셜라이저를 사용할 수 없습니다.|
|컴파일러 오류 C3447|더 이상 사용되지 않습니다.|
|컴파일러 오류 C3448|더 이상 사용되지 않습니다.|
|컴파일러 오류 C3449|더 이상 사용되지 않습니다.|
|[컴파일러 오류 C3450](compiler-error-c3450.md)|'*type*': 특성이 아닙니다. [System:: AttributeUsageAttribute]/[Windows:: Foundation:: Metadata:: AttributeUsageAttribute]를 지정할 수 없습니다.|
|[컴파일러 오류 C3451](compiler-error-c3451.md)|'*attribute*': '*type*'에 관리 되지 않는 특성을 적용할 수 없습니다.|
|[컴파일러 오류 C3452](compiler-error-c3452.md)|목록 인수 멤버가 상수가 아닙니다.|
|[컴파일러 오류 C3453](compiler-error-c3453.md)|'*attribute*': '*한정자*' 한정자가 일치 하지 않아 특성이 적용 되지 않았습니다.|
|[컴파일러 오류 C3454](compiler-error-c3454.md)|[attribute]는 클래스 선언에 사용할 수 없습니다.|
|[컴파일러 오류 C3455](compiler-error-c3455.md)|'*attribute*': 인수와 일치 하는 특성 생성자가 없습니다.|
|[컴파일러 오류 C3456](compiler-error-c3456.md)|[소스\_annotation_attribute]은 (는) 관리 되는/WinRT 클래스 선언에서 사용할 수 없습니다.|
|[컴파일러 오류 C3457](compiler-error-c3457.md)|'*attribute*': 특성은 명명 되지 않은 인수를 지원 하지 않습니다.|
|[컴파일러 오류 C3458](compiler-error-c3458.md)|' [*attribute*] ': ' [*attribute*] ' 특성이 '*identifier*'에 대해 이미 지정 되었습니다.|
|[컴파일러 오류 C3459](compiler-error-c3459.md)|' [*attribute*] ': 특성은 클래스 인덱서 (인덱싱된 기본 속성)에만 사용할 수 있습니다.|
|[컴파일러 오류 C3460](compiler-error-c3460.md)|'*type*': 사용자 정의 형식만 전달할 수 있습니다.|
|[컴파일러 오류 C3461](compiler-error-c3461.md)|'*type*': 관리 되는/WinRT 형식만 전달할 수 있습니다.|
|[컴파일러 오류 C3462](compiler-error-c3462.md)|'*type*': 가져온 형식만 전달할 수 있습니다.|
|[컴파일러 오류 C3463](compiler-error-c3463.md)|'*type*': 형식은 ' implements ' 특성에 사용할 수 없습니다.|
|[컴파일러 오류 C3464](compiler-error-c3464.md)|'*type*' 중첩 형식은 전달할 수 없습니다.|
|[컴파일러 오류 C3465](compiler-error-c3465.md)|'*type*' 형식을 사용 하려면 '*assembly*' 어셈블리를 참조 해야 합니다.|
|[컴파일러 오류 C3466](compiler-error-c3466.md)|'*type*': 제네릭 클래스의 특수화는 전달할 수 없습니다.|
|[컴파일러 오류 C3467](compiler-error-c3467.md)|'*type*':이 형식은 이미 전달 되었습니다.|
|[컴파일러 오류 C3468](compiler-error-c3468.md)|'*type*': 어셈블리에만 형식을 전달할 수 있습니다. '*identifier*'는 어셈블리가 아닙니다.|
|[컴파일러 오류 C3469](compiler-error-c3469.md)|'*type*': 제네릭 클래스는 전달할 수 없습니다.|
|[컴파일러 오류 C3470](compiler-error-c3470.md)|'*class*': 클래스에 인덱서 (인덱싱된 기본 속성)와 operator []가 둘 다 있을 수는 없습니다.|
|컴파일러 오류 C3471|새 모듈 이름 *이름* (명령줄에서 설정)이 이전 이름 *이름과* 충돌 합니다.|
|컴파일러 오류 C3472|새 출력 파일 이름 *파일* 이름 (명령줄에서 설정)이 이전 파일 이름 *파일* 이름과 충돌 합니다.|
|컴파일러 오류 C3473|출력 경로 이름이 나 모듈 이름이 지정 되지 않았습니다.|
|컴파일러 오류 C3474|'*filename*' 출력 파일을 열 수 없습니다.|
|컴파일러 오류 C3475|입력 파일 '*filename*'에 구문 오류가 있습니다.|
|컴파일러 오류 C3476|입력을 위해 '*filename*' 파일을 열 수 없습니다.|
|컴파일러 오류 C3477|람다는 확인 되지 않은 컨텍스트에 나타날 수 없습니다.|
|컴파일러 오류 C3478|'*identifier*': 배열을 복사 하 여 캡처할 수 없습니다.|
|컴파일러 오류 C3479|람다 식에 대 한 SAL 주석은 지원 되지 않습니다.|
|[컴파일러 오류 C3480](compiler-error-c3480.md)|'*variable*': 람다 캡처 변수는 바깥쪽 함수 범위에 속해야 합니다.|
|[컴파일러 오류 C3481](compiler-error-c3481.md)|'*identifier*': 람다 캡처 변수를 찾을 수 없습니다.|
|[컴파일러 오류 C3482](compiler-error-c3482.md)|비정적 멤버 함수 내에서는 'this'는 람다 캡처로만 사용할 수 있습니다.|
|[컴파일러 오류 C3483](compiler-error-c3483.md)|'*identifier*'는 이미 람다 캡처 목록의 일부입니다.|
|[컴파일러 오류 C3484](compiler-error-c3484.md)|구문 오류: 반환 형식 앞에 '-> '가 필요 합니다.|
|[컴파일러 오류 C3485](compiler-error-c3485.md)|람다 정의에 cv 한정자를 사용할 수 없습니다.|
|컴파일러 오류 3486|더 이상 사용되지 않습니다.|
|[컴파일러 오류 C3487](compiler-error-c3487.md)|'*type*': 모든 반환 식은 같은 형식으로 추론 되어야 합니다. 이전에는 '*t r u e '* 였습니다.|
|[컴파일러 오류 C 3488](compiler-error-c3488.md)|기본 캡처 모드가 참조 인 경우에는 ' &*identifier*'를 사용할 수 없습니다.|
|[컴파일러 오류 C 3489](compiler-error-c3489.md)|기본 캡처 모드를 복사할 때 ' &*식별자*'가 필요 합니다.|
|[컴파일러 오류 C3490](compiler-error-c3490.md)|'*identifier*'는 const 개체를 통해 액세스 되 고 있으므로 수정할 수 없습니다.|
|[컴파일러 오류 C3491](compiler-error-c3491.md)|'*identifier*': 변경 불가능 한 람다에서 복사 방식 캡처를 수정할 수 없습니다.|
|[컴파일러 오류 C3492](compiler-error-c3492.md)|'*identifier*': 익명 공용 구조체의 멤버를 캡처할 수 없습니다.|
|[컴파일러 오류 C3493](compiler-error-c3493.md)|지정 된 기본 캡처 모드가 없기 때문에 '*identifier*'를 암시적으로 캡처할 수 없습니다.|
|컴파일러 오류 C3494|바깥쪽 캡처 모드에서 허용 하지 않으므로 ' t r u e '를 명시적으로 캡처할 수 없습니다.|
|[컴파일러 오류 C3495](compiler-error-c3495.md)|'*identifier*': 캡처의 식별자는 람다의 연결 범위에서 선언 된 자동 저장 기간이 있는 변수 여야 합니다.|
|[컴파일러 오류 C3496](compiler-error-c3496.md)|'this'는 항상 값으로 캡처됩니다. '&'가 무시되었습니다.|
|컴파일러 오류 C3497|람다의 인스턴스를 생성할 수 없습니다.|
|[컴파일러 오류 C3498](compiler-error-c3498.md)|'*identifier*': 관리 되는/WinRT 형식이 있는 변수를 캡처할 수 없습니다.|
|[컴파일러 오류 C3499](compiler-error-c3499.md)|반환 형식이 void로 지정된 람다가 값을 반환할 수 없습니다.|

## <a name="see-also"></a>참고 항목

[C/C++ 컴파일러 및 빌드 도구 오류 및 경고](../compiler-errors-1/c-cpp-build-errors.md) \
[컴파일러 오류 C2000-C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)

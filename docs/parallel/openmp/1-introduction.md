---
title: 1. 소개
ms.date: 01/16/2019
ms.assetid: c42e72bc-0e31-4b1c-b670-cd82673c0c5a
ms.openlocfilehash: e2857565f7838ae45ff88ea53ba714e1418116ff
ms.sourcegitcommit: f2a135d69a2a8ef1777da60c53d58fe06980c997
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/03/2020
ms.locfileid: "87521176"
---
# <a name="1-introduction"></a>1. 소개

이 문서에서는 C 및 c + + 프로그램에서 공유 메모리 병렬 처리를 지정 하는 데 사용할 수 있는 컴파일러 지시문, 라이브러리 함수 및 환경 변수 컬렉션을 지정 합니다. 이 문서에서 설명 하는 기능을 통칭 하 여 *OpenMP C/c + + API (응용 프로그램 인터페이스)* 라고 합니다. 이 사양의 목표는 여러 공급 업체의 공유 메모리 아키텍처에서 프로그램을 이식할 수 있도록 하는 병렬 프로그래밍을 위한 모델을 제공 하는 것입니다. 많은 공급 업체의 컴파일러는 OpenMP C/c + + API를 지원 합니다. Openmp *포트란 응용 프로그램 인터페이스*를 비롯 한 openmp에 대 한 자세한 내용은 다음 웹 사이트에서 찾을 수 있습니다.

[https://www.openmp.org](https://www.openmp.org)

이 문서에 정의 된 지시문, 라이브러리 함수 및 환경 변수를 사용 하 여 이식성을 허용 하는 동시에 병렬 프로그램을 만들고 관리할 수 있습니다. 지시문은 단일 프로그램 (SPMD) 구문, 작업 공유 구문 및 동기화 구문을 사용 하 여 C 및 c + + 순차 프로그래밍 모델을 확장 합니다. 또한 데이터 공유 및 개인화 지원 합니다. OpenMP C 및 c + + API를 지 원하는 컴파일러에는 모든 OpenMP 컴파일러 지시문을 활성화 하 고 해석 하는 컴파일러에 대 한 명령줄 옵션이 포함 되어 있습니다.

## <a name="11-scope"></a>1.1 범위

이 사양은 컴파일러와 런타임 시스템에서 프로그램을 병렬로 실행 하기 위해 수행 하는 작업을 명시적으로 정의 하는 사용자 지향 병렬 처리에만 적용 됩니다. OpenMP C 및 c + + 구현은 종속성, 충돌, 교착 상태, 경합 상태 또는 잘못 된 프로그램 실행을 초래 하는 기타 문제를 확인 하는 데 필요 하지 않습니다. OpenMP C 및 c + + API 구문을 사용 하는 응용 프로그램이 제대로 실행 되는지 확인 해야 합니다. 컴파일러에서 이러한 병렬화를 지원 하기 위해 컴파일러에 자동 병렬화 및 지시문이이 문서에서 다루지 않습니다.

## <a name="12-definition-of-terms"></a>1.2 용어 정의

이 문서에는 다음과 같은 용어가 사용 됩니다.

- barrier

  팀의 모든 스레드가 도달 해야 하는 동기화 지점입니다.  각 스레드는 팀의 모든 스레드가이 시점에서 도착할 때까지 대기 합니다. 지시문 및 구현에 의해 생성 된 암시적 장벽으로 식별 되는 명시적 장벽을 있습니다.

- construct

  구문은 문입니다. 지시문과 구조적 블록으로 구성 됩니다. 일부 지시문은 구문의 일부가 아닙니다. [부록 C](c-openmp-c-and-cpp-grammar.md)의 *openmp 지시문* 을 참조 하십시오.

- 지시문

  C 또는 c + +와 `#pragma` 그 뒤에 `omp` 식별자, 다른 텍스트 및 줄 바꿈이 있습니다. 지시문은 프로그램 동작을 지정 합니다.

- 동적 익스텐트

  어휘 *익스텐트의*모든 문 및 어휘 범위 내에서 문의 실행 결과로 실행 되는 함수 내의 모든 문입니다. 동적 익스텐트를 *영역*이 라고도 합니다.

- 어휘 익스텐트

  *구조화 된 블록*내에서 어휘 적으로 저장 된 문

- 마스터 스레드

  *병렬 영역* 을 입력할 때 팀을 만드는 스레드입니다.

- 병렬 영역

  OpenMP 병렬 구문에 바인딩되고 많은 스레드에서 실행 될 수 있는 문입니다.

- private

  Private 변수는 참조를 만드는 스레드에 고유한 저장소 블록의 이름을로 설정 합니다. 변수가 private 임을 지정 하는 방법에는 여러 가지가 있습니다. 즉, 병렬 영역, `threadprivate` 지시문,,, `private` 또는 절 내의 정의 `firstprivate` `lastprivate` `reduction` 또는 **`for`** **`for`** 또는 지시문 바로 다음에 오는 루프에서 루프 제어 변수로 변수를 사용 `for` `parallel for` 합니다.

- region

  동적 익스텐트입니다.

- 직렬 지역

  모든 *병렬 영역의*동적 범위 밖에 있는 *마스터 스레드에서만* 실행 되는 문입니다.

- serialize

  를 사용 하 여 병렬 구문을 실행 하려면 다음을 수행 합니다.

  - 단일 스레드만 구성 된 스레드 팀 (해당 병렬 구문에 대 한 마스터 스레드)

  - 구조적 블록 내에서 문 실행의 일련 순서 (블록이 병렬 구문의 일부가 아닌 경우와 동일한 순서)

  - 에서 반환 하는 값에는 영향을 주지 않습니다 `omp_in_parallel()` . 중첩 된 병렬 구문의 효과와는 차이가 없습니다.

- 공유

  공유 변수는 단일 저장소 블록의 이름을 갖습니다. 이 변수에 액세스 하는 팀의 모든 스레드는이 단일 저장소 블록에도 액세스할 수 있습니다.

- 구조화 된 블록

  구조화 된 블록은 단일 항목과 단일 종료를 포함 하는 문 (단일 또는 복합)입니다. 문을 이동 하거나 외부로 이동 하는 경우 해당 문은 구조화 된 블록입니다. 이 규칙에는에 대 `longjmp` 한 호출이 포함 되어 있습니다. (3C) 또는에 대 한 `throw` 호출이 허용 되지만를 사용 합니다 `exit` . 항상 해당 실행이 시작 시에 시작 되 `{` 고 항상 closing에서 종료 되는 경우 `}` 복합 문은 구조화 된 블록입니다. 식 문, 선택 문, 반복 문 또는 블록은 해당 하는 **`try`** 복합 문이 구조화 된 블록이 며이를에 포함 하 여 가져온 해당 복합 문이 구조화 된 블록입니다 `{` `}` . 점프 문, 레이블 문 또는 선언 문은 구조화 된 블록이 아닙니다.

- 팀

  하나 이상의 스레드가 구문 실행의 협동입니다.

- 스레드(thread)

  제어의 직렬 흐름, 전용 변수 집합 및 공유 변수에 대 한 액세스를 포함 하는 실행 엔터티입니다.

- 변수

  네임 스페이스 이름으로 정규화 된 식별자로, 개체의 이름을 지정할 수도 있습니다.

## <a name="13-execution-model"></a>1.3 실행 모델

OpenMP는 병렬 실행의 포크 조인 모델을 사용 합니다. 이 포크 조인 모델은 다양 한 문제를 해결 하는 데 유용할 수 있지만, 많은 배열 기반 응용 프로그램에 맞게 조정 됩니다. OpenMP는 병렬 프로그램 (많은 실행 스레드 및 전체 OpenMP 지원 라이브러리)으로 올바르게 실행 되는 프로그램을 지원 하기 위한 것입니다. 순차 프로그램 (지시문이 무시 되 고 간단한 OpenMP 스텁 라이브러리)으로 올바르게 실행 되는 프로그램에도 해당 합니다. 그러나 순차적으로 실행 될 때 제대로 동작 하지 않는 프로그램을 개발 하는 것은 가능 합니다. 또한 다양 한 병렬 처리로 인해 숫자 작업의 연결이 변경 되어 숫자 결과가 달라질 수 있습니다. 예를 들어 직렬 추가 감소는 병렬 감소와는 다른 패턴의 추가 연결을 포함할 수 있습니다. 이러한 서로 다른 연결은 부동 소수점 추가의 결과를 변경할 수 있습니다.

OpenMP C/c + + API를 사용 하 여 작성 된 프로그램은 *마스터 스레드*라는 실행의 단일 스레드로 실행을 시작 합니다. 마스터 스레드는 첫 번째 병렬 구문이 나타날 때까지 직렬 지역에서 실행 됩니다. OpenMP C/c + + API에서 `parallel` 지시문은 병렬 구문을 구성 합니다. 병렬 구문이 발생 하면 마스터 스레드가 스레드 팀을 만들고 마스터는 팀의 마스터가 됩니다. 팀의 각 스레드는 작업 공유 구문을 제외 하 고 병렬 영역의 동적 범위에서 문을 실행 합니다. 팀의 모든 스레드는 동일한 순서로 작업 공유 구문을 발생 하 고 하나 이상의 스레드가 연결 된 구조적 블록 내에서 문을 실행 해야 합니다. 절이 없는 작업 공유 생성자의 끝에 포함 된 장애물은 `nowait` 팀의 모든 스레드에 의해 실행 됩니다.

스레드가 공유 개체를 수정 하는 경우 해당 개체의 실행 환경 뿐만 아니라 프로그램의 다른 스레드에도 영향을 줍니다. 개체를 volatile로 선언 하는 경우에만, 다음 시퀀스 위치 (기본 언어에 정의 됨)에서 다른 스레드의 관점에서 수정이 완료 됩니다. 그렇지 않은 경우 수정 스레드를 먼저 수정 해야 합니다. 다른 스레드 (또는 동시)는 `flush` 개체를 지정 하는 지시문 (암시적 또는 명시적)을 참조 합니다. `flush`다른 OpenMP 지시문에서 암시 하는 지시문이 파생 결과의 올바른 순서를 보장 하지 않는 경우 추가 명시적인 지시문을 제공 해야 합니다 `flush` .

병렬 구문이 완료 되 면 팀의 스레드가 암시적 장벽에서 동기화 되 고 마스터 스레드만 실행을 계속 합니다. 단일 프로그램에서 여러 개의 병렬 구문을 지정할 수 있습니다. 따라서 프로그램은 실행 중에 여러 번 분기 및 조인 될 수 있습니다.

OpenMP C/c + + API를 사용 하면 프로그래머가 병렬 구문 내에서 호출 된 함수에 지시문을 사용할 수 있습니다. 병렬 구문의 어휘 범위에는 표시 되지 않지만 동적 범위에 있을 수 있는 지시문은 *분리* 된 지시문 이라고 합니다. 프로그래머는 분리 된 지시문을 사용 하 여 프로그램의 주요 부분을 병렬로 실행할 수 있습니다. 단, 순차 프로그램을 최소한으로 변경 하면 됩니다. 이 기능을 사용 하면 프로그램 호출 트리의 최상위 수준에서 병렬 구문을 코딩 하 고 지시문을 사용 하 여 호출 된 모든 함수에서 실행을 제어할 수 있습니다.

동일한 파일에 쓰는 C 및 c + + 출력 함수에 대 한 동기화 되지 않은 호출로 인해 다른 스레드에 의해 작성 된 데이터가 비결 정적으로 표시 될 수 있습니다. 마찬가지로 동일한 파일에서 읽는 입력 함수에 대해 동기화 되지 않은 호출은 비결 정적 순서로 데이터를 읽을 수 있습니다. 각 스레드가 다른 파일에 액세스 하 고 i/o 함수의 직렬 실행과 동일한 결과를 생성 하는 i/o의 동기화 되지 않은 사용.

## <a name="14-compliance"></a>1.4 규격

OpenMP C/c + + API의 구현은 1, 2, 3, 4 및 부록 C 단원에서 설명 하는 것 처럼이 사양의 모든 요소에 대 한 의미 체계를 인식 하 고 유지 하는 경우 *openmp 규격* 입니다. 부록 A, B, D, E 및 F는 정보를 제공 하기 위한 것 이며 사양의 일부가 아닙니다. API의 하위 집합만 포함 하는 구현은 OpenMP 규격이 아닙니다.

OpenMP C 및 c + + API는 구현에서 지원 되는 기본 언어에 대 한 확장입니다. 기본 언어가이 문서에 표시 되는 언어 구문 또는 확장명을 지원 하지 않는 경우이를 지원 하기 위해 OpenMP 구현이 필요 하지 않습니다.

모든 표준 C 및 c + + 라이브러리 함수와 기본 제공 함수 (즉, 컴파일러에 특정 정보가 있는 함수)는 스레드로부터 안전 해야 합니다. 병렬 영역 내의 여러 스레드에 의해 스레드로부터 안전한 함수를 동기화 하지 않는 경우 정의 되지 않은 동작이 생성 되지 않습니다. 그러나이 동작은 직렬 지역에서와 같지 않을 수 있습니다. (난수 생성 함수는 예입니다.)

OpenMP C/c + + API는 특정 동작이 *구현에 정의* 되도록 지정 합니다. 이러한 경우에는 해당 동작을 정의 하 고 문서화 하는 데 준수 하는 OpenMP 구현이 필요 합니다. 구현 정의 동작 목록은 [부록 E](e-implementation-defined-behaviors-in-openmp-c-cpp.md)를 참조 하세요.

## <a name="15-normative-references"></a>1.5 표준 참조

- ISO/IEC 9899:1999, *정보 기술 프로그래밍 언어-C*. 이 OpenMP API 사양은 C99로 ISO/IEC 9899:1999을 참조 합니다.

- ISO/IEC 9899:1990, *정보 기술 프로그래밍 언어-C*. 이 OpenMP API 사양은 C90로 ISO/IEC 9899:1990을 참조 합니다.

- ISO/IEC 14882:1998, *정보 기술 프로그래밍 언어-c + +*. 이 OpenMP API 사양은 ISO/IEC 14882:1998를 c + +로 나타냅니다.

이 OpenMP API 사양이 C를 참조 하는 경우에는 구현에서 지 원하는 기본 언어로 참조가 생성 됩니다.

## <a name="16-organization"></a>1.6 조직

- [런타임 라이브러리 함수](3-run-time-library-functions.md)
- [환경 변수](4-environment-variables.md)
- [OpenMP C/C++에서 구현이 정의된 동작](e-implementation-defined-behaviors-in-openmp-c-cpp.md)
- [OpenMP C/c + + 버전 2.0의 새로운 기능](f-new-features-and-clarifications-in-version-2-0.md)
